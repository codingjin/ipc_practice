/* CS 519, FALL 2019: HW-1 
 * IPC using pipes to perform matrix multiplication.
 * Feel free to extend or change any code or functions below.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/wait.h>

//Add all your global variables and definitions here.
#define MATRIX_SIZE 1000
#define BUF_SIZE 256
#define CHILDREN_NUM 50
#define KEY 0x1111
#define PIPELIMIT 1

struct sembuf p = {0, -1, SEM_UNDO};
struct sembuf v = {0, +1, SEM_UNDO};
typedef union semun {
	int value;
	struct semid_ds *buf;
	unsigned short *array;
}semun;
semun pipect;


int **Matrix(int m, int n);
int **Matrix0(int m, int n);
void printMatrix(int **M, int m, int n);
void freeMatrix(int **M, int m);
void MatrixMultiplication(int **M, int **A, int **B, int m, int n, int k);
int MatrixCompare(int **M, int **N, int m, int n);
int getSemid();
void setPipeLimit(int value);
void initSemctl(int id);
void P(int id);
void V(int id);


/* Time function that calculates time between start and end */
double getdetlatimeofday(struct timeval *begin, struct timeval *end)
{
    return (end->tv_sec + end->tv_usec * 1.0 / 1000000) -
           (begin->tv_sec + begin->tv_usec * 1.0 / 1000000);
}


/* Stats function that prints the time taken and other statistics that you wish
 * to provide.
 */
void print_stats() {



}


int main(int argc, char const *argv[])
{
	if(argc != 5) {
		fprintf(stderr, "Invalid command! Standard command is ./IPC-pipe integer1 integer2 integer3 integer4\nThese 4 integers are the dimensions for the 2 matrixes\n");
		return 1;
	}
	int m=atoi(argv[1]), m1=atoi(argv[2]), m2=atoi(argv[3]), n=atoi(argv[4]);
	if(m<1 || m1<1 || m2<1 || n<1 || m1!=m2) {
		fprintf(stderr, "Invalid input arguments!\n");
		return 1;
	}
	if(m>MATRIX_SIZE)	m=MATRIX_SIZE;
	if(n>MATRIX_SIZE)	n=MATRIX_SIZE;

	int pipefd1[2], pipefd2[2];
	char inbuf[BUF_SIZE];
	char outbuf[BUF_SIZE];
	if(pipe(pipefd1) < 0) {
		fprintf(stderr, "pipe() failed!\n");
		return 1;
	}
	if(pipe(pipefd2) < 0) {
		fprintf(stderr, "pipe() failed!\n");
		return 1;
	}
	int **A = Matrix(m, m1);
	int **B = Matrix(m2, n);
	int **C = Matrix0(m, n);
	
	printf("MatrixA is A =\n");
	printMatrix(A, m, m1);
	printf("MatrixB is B =\n");
	printMatrix(B, m2, n);
	MatrixMultiplication(C, A, B, m, n, m1);
	printf("MatrixA * MatrixB =\n");
	printMatrix(C, m, n);
	
	// semaphores
	int semid = getSemid();
	initSemctl(semid);

	int **Cnew = Matrix0(m, n);

	pid_t fid;
	for(int i=0;i<CHILDREN_NUM;++i) {
		fid = fork();
		if(fid < 0) {
			fprintf(stderr, "fork failed!\n");
			return 1;
		}else if(fid == 0) {
			// child
			close(pipefd1[1]);
			close(pipefd2[0]);
			//int pp = (int)getpid();
			int ii, jj, kk, tmp;
			while(read(pipefd1[0], inbuf, BUF_SIZE) > 0) {
				// child process receives the tasks from parent
				sscanf(inbuf, "%d %d", &ii, &jj);
				// computing
				tmp = 0;
				for(kk=0;kk<m1;++kk)
					tmp += A[ii][kk] * B[kk][jj];
				// return the result back to parent
				sprintf(outbuf, "%d %d %d", ii, jj, tmp);
				P(semid);
				write(pipefd2[1], outbuf, BUF_SIZE);
				V(semid);
			}
			close(pipefd1[0]);
			close(pipefd2[1]);
			return 0;
		}
	}

	// parent
	close(pipefd1[0]);
	
	// parent assign the tasks to the child processes
	for(int i=0;i<m;++i) {
		for(int j=0;j<n;++j) {
			sprintf(outbuf, "%d %d", i, j);
			write(pipefd1[1], outbuf, BUF_SIZE);
		}
	}
	close(pipefd1[1]);
	close(pipefd2[1]);

	// parent get the results from child processes
	int ii, jj, result;
	while(read(pipefd2[0], inbuf, BUF_SIZE) > 0) {
		sscanf(inbuf, "%d %d %d", &ii, &jj, &result);
		Cnew[ii][jj] = result;
	}
	
	printf("We get the result!\nCnew = \n");
	printMatrix(Cnew, m, n);

	if(MatrixCompare(C, Cnew, m, n))	printf("The Matrix Multiplication is correct!\n");
	else	printf("The Matrix Multiplication is incorrect!\n");

   print_stats(); 
   return 0;
}


int **Matrix(int m, int n) {
	int **M = (int**)malloc(m * sizeof(int*));
	if(M == NULL) {
		fprintf(stderr, "Fail to malloc for Matrix\n");
		exit(1);
	}
	for(int i=0;i<m;++i) {
		M[i] = (int*)malloc(n * sizeof(int));
		if(M[i] == NULL) {
			fprintf(stderr, "Fail to malloc for M[%d]\n", i);
			exit(1);
		}
		for(int j=0;j<n;++j)	M[i][j] = rand() % 3;
	}
	return M;
}

int **Matrix0(int m, int n) {
	int **M = (int**)malloc(m * sizeof(int*));
	if(M == NULL) {
		fprintf(stderr, "Fail to malloc for Matrix\n");
		exit(1);
	}
	for(int i=0;i<m;++i) {
		M[i] = (int*)malloc(n * sizeof(int));
		if(M[i] == NULL) {
			fprintf(stderr, "Fail to malloc for M[%d]\n", i);
			exit(1);
		}
		memset(M[i], 0, n*sizeof(int));
	}
	return M;
}

void freeMatrix(int **M, int m) {
	for(int i=0;i<m;++i)
		free(M[i]);

	free(M);
}

void printMatrix(int **M, int m, int n) {
	for(int i=0;i<m;++i) {
		for(int j=0;j<n;++j)	printf("%d ", M[i][j]);
		printf("\n");
	}
	printf("\n\n");
}

void MatrixMultiplication(int **M, int **A, int **B, int m, int n, int k) {
	for(int i=0;i<m;++i)
		for(int j=0;j<n;++j) {
			M[i][j] = 0;
			for(int kk=0;kk<k;++kk)	M[i][j] += A[i][kk]*B[kk][j];
		}
}

int MatrixCompare(int **M, int **N, int m, int n) {
	for(int i=0;i<m;++i)	for(int j=0;j<n;++j)	if(M[i][j] != N[i][j])	return 0;
	return 1;
}

int getSemid() {
	int id = semget(KEY, 1, 0666 | IPC_CREAT);
	if(id < 0) {
		fprintf(stderr, "semget fails!\n");
		exit(1);
	}
	return id;
}

void setPipeLimit(int value) {
	pipect.value = value;
}

void initSemctl(int id) {
	setPipeLimit(PIPELIMIT);
	if(semctl(id, 0, SETVAL, pipect) < 0) {
		fprintf(stderr, "semctl fails!\n");
		exit(1);
	}
}

void P(int id) {
	if(semop(id, &p, 1) < 0) {
		fprintf(stderr, "semopP fails!\n");
		exit(1);
	}
}

void V(int id) {
	if(semop(id, &v, 1) < 0) {
		fprintf(stderr, "semopV fails!\n");
		exit(1);
	}
}



