/* CS 519, FALL 2019: HW-1 
 * IPC using pipes to perform matrix multiplication.
 * Feel free to extend or change any code or functions below.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/wait.h>

//Add all your global variables and definitions here.
#define MATRIX_SIZE 1000
#define BUF_SIZE 2048
#define CHILDREN_NUM 50
#define PAKAGE_SIZE 64

int **Matrix(int m, int n);
int **Matrix0(int m, int n);
void printMatrix(int **M, int m, int n);
void freeMatrix(int **M, int m);
void MatrixMultiplication(int **M, int **A, int **B, int m, int n, int k);
int MatrixCompare(int **M, int **N, int m, int n);

/* Time function that calculates time between start and end */
double getdetlatimeofday(struct timeval *begin, struct timeval *end)
{
    return (end->tv_sec + end->tv_usec * 1.0 / 1000000) -
           (begin->tv_sec + begin->tv_usec * 1.0 / 1000000);
}

int main(int argc, char const *argv[])
{
	if(argc != 5) {
		fprintf(stderr, "Invalid command! Standard command is ./IPC-pipe integer1 integer2 integer3 integer4\nThese 4 integers are the dimensions for the 2 matrixes\n");
		return 1;
	}
	int m=atoi(argv[1]), m1=atoi(argv[2]), m2=atoi(argv[3]), n=atoi(argv[4]);
	if(m<1 || m1<1 || m2<1 || n<1 || m1!=m2) {
		fprintf(stderr, "Invalid input arguments!\n");
		return 1;
	}
	if(m>MATRIX_SIZE)	m=MATRIX_SIZE;
	if(n>MATRIX_SIZE)	n=MATRIX_SIZE;

	int pipefd[2];
	char inbuf[BUF_SIZE];
	char outbuf[BUF_SIZE];
	if(pipe(pipefd) < 0) {
		fprintf(stderr, "pipe() failed!\n");
		return 1;
	}
	int **A = Matrix(m, m1);
	int **B = Matrix(m2, n);
	int **C = Matrix0(m, n);
	
	/*
	printf("MatrixA is A =\n");
	printMatrix(A, m, m1);
	printf("MatrixB is B =\n");
	printMatrix(B, m2, n);
	*/
	
	//MatrixMultiplication(C, A, B, m, n, m1);
	//printf("MatrixA * MatrixB =\n");
	//printMatrix(C, m, n);
	int **Cnew = Matrix0(m, n);
	pid_t fid;
	int total = m*n;
	int len = total / (CHILDREN_NUM+1);
	struct timeval tbeg, tend;
	// Time begin
	gettimeofday(&tbeg, NULL);
	int id;
	for(id=0;id<CHILDREN_NUM;++id) {
		fid = fork();
		if(fid < 0) {
			fprintf(stderr, "fork failed!\n");
			return 1;
		}else if(fid == 0) {
			// child
			close(pipefd[0]);
			if(len!=0) {
				int k, i, j;
				int beg=len*id, end=len*(id+1) - 1;
				int i0=beg/n, j0=beg-n*i0, i1=end/n, j1=end-n*i1;
				if(i0<i1) {
					// C[i0][j0:n-1]
					for(k=0;k<m1;++k)	for(j=j0;j<n;++j)	C[i0][j] += A[i0][k]*B[k][j];
					for(j=j0;j<n;++j) {
						sprintf(outbuf, "%d %d %d", i0, j, C[i0][j]);
						write(pipefd[1], outbuf, BUF_SIZE);
					}

					// C[i0+1:i1-1][0:n-1]
					for(k=0;k<m1;++k)	for(i=i0+1;i<i1;++i)	for(j=0;j<n;++j)	C[i][j] += A[i][k]*B[k][j];
					for(i=i0+1;i<i1;++i) {
						for(j=0;j<n;++j) {
							sprintf(outbuf, "%d %d %d", i, j, C[i][j]);
							write(pipefd[1], outbuf, BUF_SIZE);
						}
					}

					// C[i1][0:j1]
					for(k=0;k<m1;++k)	for(j=0;j<=j1;++j)	C[i1][j]+=A[i1][k]*B[k][j];
					for(j=0;j<=j1;++j) {
						sprintf(outbuf, "%d %d %d", i1, j, C[i1][j]);
						write(pipefd[1], outbuf, BUF_SIZE);
					}
				}else { // i0==i1
					for(k=0;k<m1;++k)	for(j=j0;j<=j1;++j)	C[i0][j]+=A[i0][k]*B[k][j];
					for(j=j0;j<=j1;++j) {
						sprintf(outbuf, "%d %d %d", i0, j, C[i0][j]);
						write(pipefd[1], outbuf, BUF_SIZE);
					}
				}
			}else { // len==0
				if(id<total) {
					int i=id/n, j=id-n*i;
					for(int k=0;k<m1;++k)	C[i][j]+=A[i][k]*B[k][j];
					sprintf(outbuf, "1 %d %d %d ", i, j, C[i][j]);
					write(pipefd[1], outbuf, BUF_SIZE);
				}
			}
			close(pipefd[1]);
			freeMatrix(A, m);
			freeMatrix(B, m2);
			freeMatrix(C, m);
			return 0;
		}
	}

	// parent
	close(pipefd[1]);
	if(len != 0) { // now id represents this parent!
		int k, i, j;
		int beg=len*id; // Since it is the last process, so will finish all, which means end=total-1;
		int i0=beg/n, j0=beg-n*i0;
		if(i0<m-1) {
			// C[i0][j0:n-1]
			for(k=0;k<m1;++k)	for(j=j0;j<n;++j)	C[i0][j] += A[i0][k]*B[k][j];
			// finish the rest
			for(k=0;k<m1;++k)	for(i=i0+1;i<m;++i)	for(j=0;j<n;++j)	C[i][j] += A[i][k]*B[k][j];
		}else { // i0==m-1
			for(k=0;k<m1;++k)	for(j=j0;j<n;++j)	C[i0][j]+=A[i0][k]*B[k][j];
		}
	}


	// parent gets the results from pipefd[0]
	int i,j,result;
	while(read(pipefd[0], inbuf, BUF_SIZE) > 0) {
		sscanf(inbuf, "%d %d %d", &i, &j, &result);
		//if(j==n-1)	printf("%d %d %d\n", i, j, result);
		C[i][j] = result;
	}
	
	MatrixMultiplication(Cnew, A, B, m, n, m1);
	/*
	printf("MatrixC is C =\n");
	printMatrix(C, m, n);
	printf("MatrixCnew is Cnew =\n");
	printMatrix(Cnew, m, n);
	*/
	// parent assign the tasks to the child processes
	/*
	int ii, jj, result;
	if(n <= 200) {
		for(int i=0;i<m;++i) {
			for(int j=0;j<n;++j) {
				sprintf(outbuf, "%d %d", i, j);
				write(pipefd1[1], outbuf, BUF_SIZE);
			}
			for(int j=0;j<n;++j) {
				read(pipefd2[0], inbuf, BUF_SIZE);
				sscanf(inbuf, "%d %d %d", &ii, &jj, &result);
				Cnew[ii][jj] = result;
			}
		}
	}else {
		int counter = 0;
		for(int i=0;i<m;++i) {
			for(int j=0;j<n;++j) {
				sprintf(outbuf, "%d %d", i, j);
				write(pipefd1[1], outbuf, BUF_SIZE);
				++counter;
				if(counter == 200) {
					while(counter) {
						read(pipefd2[0], inbuf, BUF_SIZE);
						sscanf(inbuf, "%d %d %d", &ii, &jj, &result);
						Cnew[ii][jj] = result;
						--counter;
					}
				}
			}
			while(counter) {
				read(pipefd2[0], inbuf, BUF_SIZE);
				sscanf(inbuf, "%d %d %d", &ii, &jj, &result);
				Cnew[ii][jj] = result;
				--counter;
			}
		}
	}
	*/
	// Time end
	gettimeofday(&tend, NULL);
	printf("Time taken:%lf\n", getdetlatimeofday(&tbeg, &tend));
	close(pipefd[0]);
	//printf("We get the result!\nCnew = \n");
	//printMatrix(Cnew, m, n);

	if(MatrixCompare(C, Cnew, m, n))	printf("The Matrix Multiplication is correct!\n");
	else								printf("The Matrix Multiplication is incorrect!\n");
	
	freeMatrix(A, m);
	freeMatrix(B, m2);
	freeMatrix(C, m);
	freeMatrix(Cnew, m);
	return 0;
}


int **Matrix(int m, int n) {
	int **M = (int**)malloc(m * sizeof(int*));
	if(M == NULL) {
		fprintf(stderr, "Fail to malloc for Matrix\n");
		exit(1);
	}
	for(int i=0;i<m;++i) {
		M[i] = (int*)malloc(n * sizeof(int));
		if(M[i] == NULL) {
			fprintf(stderr, "Fail to malloc for M[%d]\n", i);
			exit(1);
		}
		for(int j=0;j<n;++j)	M[i][j] = rand() % 3;
	}
	return M;
}

int **Matrix0(int m, int n) {
	int **M = (int**)malloc(m * sizeof(int*));
	if(M == NULL) {
		fprintf(stderr, "Fail to malloc for Matrix\n");
		exit(1);
	}
	for(int i=0;i<m;++i) {
		M[i] = (int*)malloc(n * sizeof(int));
		if(M[i] == NULL) {
			fprintf(stderr, "Fail to malloc for M[%d]\n", i);
			exit(1);
		}
		memset(M[i], 0, n*sizeof(int));
	}
	return M;
}

void freeMatrix(int **M, int m) {
	for(int i=0;i<m;++i)
		free(M[i]);
	free(M);
}

void printMatrix(int **M, int m, int n) {
	for(int i=0;i<m;++i) {
		for(int j=0;j<n;++j)	printf("%d ", M[i][j]);
		printf("\n");
	}
	printf("\n\n");
}

void MatrixMultiplication(int **M, int **A, int **B, int m, int n, int k) {
	for(int i=0;i<m;++i)
		for(int j=0;j<n;++j) {
			M[i][j] = 0;
			for(int kk=0;kk<k;++kk)	M[i][j] += A[i][kk]*B[kk][j];
		}
}

int MatrixCompare(int **M, int **N, int m, int n) {
	for(int i=0;i<m;++i)	for(int j=0;j<n;++j)	if(M[i][j] != N[i][j])	return 0;
	return 1;
}


